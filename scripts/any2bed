#!/usr/bin/env perl
use strict;
use warnings;

# Core modules
use Data::Dumper;
use Getopt::Long;
use List::Util qw/sum/;
use File::Basename qw/fileparse basename/;
use File::Find qw/find/;

# threads modules
use threads;
use Thread::Queue;

# global file extensions
my @fastqExt=qw(.fastq.gz .fastq .fq .fq.gz);
my @fastaExt=qw(.fasta .fna .faa .mfa .fas .fa);
my @bamExt=qw(.sorted.bam .bam);
my @samExt=qw(.sam);
my @vcfExt=qw(.vcf.gz .vcf);
my @richseqExt=qw(.gbk .gb .embl);

my $fastaExtRegex=join('$|',@fastaExt).'$';
my $bamExtRegex=join('$|',@bamExt).'$';
my $samExtRegex=join('$|',@samExt).'$';
my $vcfExtRegex=join('$|',@vcfExt).'$';

local $0=fileparse $0;
sub logmsg {print STDERR "$0: @_\n"};
exit(main());
sub main{
  my $settings={};
  GetOptions($settings,qw(help chunksize=i numchunks=i numcpus=i minlength=i overlapby=i));
  die usage() if($$settings{help});
  $$settings{minlength}||=1;
  $$settings{chunksize}||=0;
  $$settings{overlapby}||=0;
  if(!$$settings{chunksize}){
    $$settings{numchunks}||=1;
  }
  $$settings{numcpus}||=1;
  die "ERROR: need infile file!\n".usage() if(!@ARGV);
  # Start off multithreading
  my $fileQ=Thread::Queue->new(@ARGV);
  my @thr;
  for my $i(0..$$settings{numcpus}-1){
    $thr[$i]=threads->new(\&contigLengthsWorker,$fileQ,$settings);
  }
  for my $infile(@ARGV){
    my $contigLength={};
    my($name,$path,$suffix)=fileparse($infile,@bamExt,@fastaExt,@vcfExt);
    logmsg "Enqueuing $infile with extension $suffix";
    $fileQ->enqueue($infile);
  }
  $fileQ->enqueue(undef) for(@thr);
  # Combine contig length results from threads
  my %cLength;
  for(@thr){
    my $tmp=$_->join;
    %cLength=(%cLength,%$tmp);
  }
  # print combined results
  printChunks(\%cLength,$settings);
  return 0;
}
sub contigLengthsWorker{
  my($fileQ,$settings)=@_;
  my $cLength={};
  while(defined(my $infile=$fileQ->dequeue)){
    my $contigLength={};
    my($name,$path,$suffix)=fileparse($infile,@bamExt,@samExt,@fastaExt,@vcfExt);
    if($suffix=~/$bamExtRegex/){
      $contigLength=bamLengths($infile,$settings);
    } elsif($suffix=~/$samExtRegex/){
      $contigLength=samLengths($infile,$settings);
    } elsif($suffix=~/$fastaExtRegex/){
      $contigLength=fastaLengths($infile,$settings);
    } elsif($suffix=~/$vcfExtRegex/){
      $contigLength=vcfLengths($infile,$settings);
    } else {
      die "ERROR: I do not understand extension $suffix from filename $infile";
    }
    # Combine
    while(my($seqname,$length)=each(%$contigLength)){
      $$cLength{$seqname}=$length if(!defined($$cLength{$seqname}));
      $$cLength{$seqname}=$length if($$cLength{$seqname} < $length);
    }
  }
  return $cLength;
}

# Read a multifasta file.
# Code taken from the CG-Pipeline project.
sub readMfa($;$) {
  my ($mfa_file, $settings) = @_;
  open(FH, '<', $mfa_file) or die("Could not open file $mfa_file for reading: ".$!);
  my %seqs;
  my ($cur_seq_hdr, $seq);
  while (<FH>) {
    if (/^\>\s*(.+)/) {
      $seqs{$cur_seq_hdr} = $seq if $cur_seq_hdr;
      undef $seq;
      $cur_seq_hdr = ($$settings{first_word_only} ? (split /\s/, $1)[0] : $1);
    } else {
      chomp; 
      s/\s//g unless($$settings{keep_whitespace});
      $seq .= uc $_;
    }
  }
  close FH;
  $seqs{$cur_seq_hdr} = $seq if $cur_seq_hdr;
  die("Error: No sequences found in $mfa_file") unless %seqs;
  return \%seqs;
}

sub fastaLengths{
  my($fasta,$settings)=@_;
  my $seqs = readMfa($fasta,{first_word_only=>1});

  my %length;
  while(my($id, $sequence) = each(%$seqs)){
    $length{$id}=length($sequence);
  }
  return \%length;
}

sub samLengths{
  my($sam, $settings)=@_;
  # Find the total length of the reference genome
  logmsg "Finding the total length of each contig";
  my %max;
  open(SAM,$sam) or die "ERROR: could not read $sam: $!";
  while(<SAM>){
    chomp;
    next if(/^\s*$/); # skip blank lines
    my($type,@F)=split /\t/;
    $type=~s/^\@//; # remove header indicator
    next if($type ne 'SQ');
    my %F;
    for(@F){
      my($key,$value)=split(/:/);
      $F{$key}=$value;
    }
    $max{$F{SN}}=$F{LN};
  }
  close SAM;
  return \%max;
}

sub bamLengths{
  my($sorted,$settings)=@_;
  # Find the total length of the reference genome
  logmsg "Finding the total length of each contig";
  my %max;
  open(BAMHEADER,"samtools view -H $sorted | ") or die "ERROR: could not use samtools view on $sorted: $!";
  while(<BAMHEADER>){
    chomp;
    my($type,@F)=split /\t/;
    $type=~s/^\@//; # remove header indicator
    next if($type ne 'SQ');
    my %F;
    for(@F){
      my($key,$value)=split(/:/);
      $F{$key}=$value;
    }
    $max{$F{SN}}=$F{LN};
  }
  close BAMHEADER;
  return \%max;
}
# Finding the length of a VCF is sort of difficult.
# There are four different ways to find it:
#   1. The ##reference line, and then parsing the fasta file
#   2. The ##contig line, and then parsing the lengths inline
#   3. The bcftools index -s function
#   4. Parsing the file to find the max coordinate per seqname (slow)
sub vcfLengths{
  my($vcf,$settings)=@_;

  # Try to find lengths using ##contig=<...>
  my $fh;
  if($vcf =~ /\.gz$/i){
    open($fh, "zgrep '^##contig' $vcf | ") or die "ERROR: could not open $vcf for reading: $!";
  } else {
    open($fh, "grep '^##contig' $vcf | ") or die "ERROR: could not open $vcf for reading: $!";
  }
  my %contigLength;
  SEARCH_VCF_FOR_CONTIG:
  while(<$fh>){
    # e.g., ##contig=<ID=NC_001416.1,length=48502,species="Escherichia virus lambda">
    if(/^##contig=<(.*)>/){
      chomp;
      logmsg "Found contig: $_";
      my $contigInfo = $1;
      my @keyvalue = split(/,/,$contigInfo);
      my %contigTag;
      for(@keyvalue){
        my($key, $value) = split /=/;
        $key = uc($key);
        $contigTag{$key} = $value;
      }
      if($contigTag{ID} && $contigTag{LENGTH}){
        $contigLength{$contigTag{ID}} = $contigTag{LENGTH};
      }
    }
  }
  close $fh;
  if(keys(%contigLength) > 0){
    return \%contigLength;
  }

  # Try to find lengths using ##reference=...
  my $fasta;
  if($vcf =~ /\.gz$/i){
    open($fh, "zgrep '^##reference' $vcf | ") or die "ERROR: could not open $vcf for reading: $!";
  } else {
    open($fh, "grep '^##reference' $vcf | ") or die "ERROR: could not open $vcf for reading: $!";
  }

  # See if ##reference=reference can be found, and if so,
  # if this script can parse that fasta file for lengths.
  SEARCH_VCF_FOR_FASTA_PATH:
  while(<$fh>){
    # VCFtools v0.1.14 filtering appends to fileformat=VCFv4.2 '##reference=file:///reference-path'
    if(/^##reference=file:\/\/(.+)/){
      $fasta=$1;
    }
    # VarScan v2.3 filtering appends to fileformat=VCFv4.1 '##reference=/reference-path'
    elsif(/^##reference=(.+)/){
      $fasta=$1;
    }
    logmsg "Reference genome specified as $fasta";
    logmsg "  searching up to 99 parent directories for $fasta";
    # Look for the fasta by going up about 99 directories
    for my $i(0..99){
      my $dirPrefix = "../" x $i;
      # Look for the fasta going up and including any relative path
      if(-e "$dirPrefix$fasta"){
        $fasta="$dirPrefix$fasta";
        logmsg "Found reference genome at $fasta";
        last SEARCH_VCF_FOR_FASTA_PATH;
      }
      # Look for the fasta going up and excluding any relative path
      if(-e "$dirPrefix".basename($fasta)){
        $fasta="$dirPrefix$fasta";
        logmsg "Found reference genome at $fasta";
        last SEARCH_VCF_FOR_FASTA_PATH;
      }
    }

    # See if the file is down any directories
    logmsg "  searching into all child folders for $fasta";
    find({wanted=>sub{
          if(basename($fasta) eq $_){
            $fasta = $File::Find::name;
            last SEARCH_VCF_FOR_FASTA_PATH;
          }
        },
        no_chdir=>0},
      "."
    );
    logmsg "Found reference genome $fasta in the vcf file but it does not exist where I expect it";
    $fasta="";
  }
  close $fh;

  # If the ##reference method found something, streamline using the fasta lengths function
  if($fasta){
    return fastaLengths($fasta,$settings);
  }

  my %max; # used for any of the next methods
  # See if bcftools can help find the length if the ref is not found
  my @bcftoolsIndex=`bcftools index --stats '$vcf' 2>/dev/null`;
  #logmsg "ERROR with command => bcftools index -s '$vcf'\n  $0 @ARGV" if $?;
  for(@bcftoolsIndex){
    chomp;
    my($seqname,$start,$stop)=split /\t/;
    $max{$seqname}=$stop;
  }
  return \%max if(keys(%max)>0);
  #die "ERROR: could not determine contig lengths for $vcf using either the ##reference tag nor 'bcftools index -s'";
  #die Dumper "ERROR",\%max;
  # If bcftools gives that BS error that it can't find the 
  # lengths of contigs with --stats, then try bcftools query
  # after figuring out what contigs are present with tabix.
  my @CHR=`tabix -l '$vcf'`;
  chomp(@CHR);
  for my $seqname(@CHR){
    my $maxPos=`bcftools query -f '%POS\\n' -r '$seqname' '$vcf' | tail -n 1`;
    $max{$seqname}=$maxPos+0;
  }
  return \%max if(keys(%max)>0);
  # If a reference is not found and bcftools didn't come through, 
  # then just find the coordinates in the file itself (slow step).
  # Reverses the coordinates using tac such that each
  # max pos is listed first for each contig.
  #open(VCFGZ,"zcat $vcf | cut -f 1,2 | sort -k1,1 -k2,2nr |") or die "ERROR: could not open $vcf for reading: $!";
  open(VCFGZ,"zcat $vcf | cut -f 1,2 | tac |") or die "ERROR: could not open $vcf for reading: $!";
  while(<VCFGZ>){
    next if(/^#/);
    my($seqname,$pos)=split /\t/;
    next if(defined($max{$seqname}));
    $max{$seqname}=$pos+0;
  }
  close VCFGZ;
  return \%max;
}
sub printChunks{
  my($contigLength,$settings)=@_;
  # If the number of chunks is set, then set the chunk length
  # equal to the size divided by the number desired.
  if($$settings{numchunks}){
    my $totalLength=sum(values(%$contigLength));
    $$settings{chunksize}=int($totalLength/$$settings{numchunks})+1;
  }
  # Print out the regions
  my $chunksize=$$settings{chunksize};
  while(my($seqname,$length)=each(%$contigLength)){
    for(my $start=1;$start<$length;$start+=$chunksize){
      my $end = $start + $chunksize - 1 + $$settings{overlapby};
      $end=$length if($end > $length);
      #print "$seqname:$start-$end\n";

      # Bed format is zero-based
      $start--;
      $end--;
      print join("\t",$seqname,$start,$end)."\n";
    }
  }
}
sub usage{
  "Prints bed format to stdout
  Usage: $0 infile [infile2...] > regions.bed
  infile must either have an extension of either .bam, .vcf.gz, or .fasta.  Bam and vcf files must be indexed.
  It's a good idea to give multiple vcf files since they don't really betray where the last coordinate is. In other words, another vcf file might have a snp beyond where the curren vcf's snps are
  --chunksize  0  The size of each region.
  --numchunks  1  If chunksize is not set, how many chunks should there be?
                  NOTE: Despite what is requested, there will be at least 
                  one chunk per contig.
  --numcpus    1
  --overlapby  0  How many bp each region should overlap by
  --minlength  1  The minimum number of base pairs allowed per chunk
  "
}
